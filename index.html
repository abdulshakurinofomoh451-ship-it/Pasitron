<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Positron Logic – WebGPU + WASM</title>
<style>
body { background:#0b0b12; color:#e6e6f0; font-family:monospace; }
canvas { border:1px solid #333; }
</style>
</head>
<body>
<h2>Positron Logic – Antimatter Stasis MVP</h2>
<canvas id="gfx" width="640" height="480"></canvas>

<script type="module">
import init, { StasisController } from './pkg/stasis_controller.js';

async function run() {
    await init();

    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();
    const queue = device.queue;

    const controller = new StasisController(262144);

    // Create particle buffer
    const particleCount = controller.particle_count();
    const particleData = new Float32Array(particleCount * 4);
    for (let i = 0; i < particleCount; i++) {
        particleData[i * 4 + 0] = Math.random() * 2 - 1;
        particleData[i * 4 + 1] = Math.random() * 2 - 1;
        particleData[i * 4 + 2] = 0;
        particleData[i * 4 + 3] = 1;
    }

    const particleBuffer = device.createBuffer({
        size: particleData.byteLength,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
    });
    new Float32Array(particleBuffer.getMappedRange()).set(particleData);
    particleBuffer.unmap();

    // Uniform buffer
    const paramBuffer = device.createBuffer({
        size: 8,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const shaderCode = await fetch('./shaders/stasis_compute.wgsl').then(r => r.text());
    const module = device.createShaderModule({ code: shaderCode });

    const pipeline = device.createComputePipeline({
        layout: 'auto',
        compute: { module, entryPoint: 'main' }
    });

    const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [
            { binding: 0, resource: { buffer: particleBuffer } },
            { binding: 1, resource: { buffer: paramBuffer } }
        ]
    });

    function frame() {
        const dt = 0.016;
        const status = controller.update_simulation(dt * 1000);
        console.log(status);

        queue.writeBuffer(paramBuffer, 0, new Float32Array([dt, 0.75]));

        const encoder = device.createCommandEncoder();
        const pass = encoder.beginComputePass();
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(Math.ceil(particleCount / 256));
        pass.end();
        queue.submit([encoder.finish()]);

        requestAnimationFrame(frame);
    }
    frame();
}

run();
</script>
</body>
</html>
